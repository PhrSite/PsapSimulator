/////////////////////////////////////////////////////////////////////////////////////
//  File:   SubscriberUac.cs                                        7 Aug 25 PHR
/////////////////////////////////////////////////////////////////////////////////////

namespace SipLib.Subscriptions;
using SipLib.Threading;
using SipLib.Transactions;
using System.Net;
using SipLib.Core;
using I3SubNot;
using Ng911Lib.Utilities;

/// <summary>
/// User Agent Client (UAC) class for managing subscriptions to the Event State, the Service State and the
/// Queue State event packages.
/// </summary>
public class SubscriberUac : QueuedActionWorkerTask
{
    private SipTransport m_SipTransport;
    private SIPURI m_NotifierSipUri;
    private IPEndPoint m_NotifierIPEndPoint;
    private const int DEFAULT_EXPIRES_SECONDS = 30;

    /// <summary>
    /// The key is the subscription event name. 
    /// </summary>
    private Dictionary<string, SubscriptionData> m_Subscriptions = new Dictionary<string, SubscriptionData>();

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="sipTransport">SipTransport to use for sending and receiving SIP messages.</param>
    /// <param name="notifierSipUri">SIPURI of the server (notifier) to send SUBSCRIBE requests to.</param>
    public SubscriberUac(SipTransport sipTransport, SIPURI notifierSipUri) : base()
    {
        m_NotifierSipUri = notifierSipUri;
        m_SipTransport = sipTransport;
        m_NotifierIPEndPoint = notifierSipUri.ToSIPEndPoint()!.GetIPEndPoint();
        m_SipTransport.SipRequestReceived += OnSipRequestReceived;

        m_Subscriptions.Add(SubNotConsts.ElementState, new SubscriptionData(SubNotConsts.ElementState, BuildSubscribeRequest(
            SubNotConsts.ElementState)));
        m_Subscriptions.Add(SubNotConsts.ServiceState, new SubscriptionData(SubNotConsts.ServiceState, BuildSubscribeRequest(
            SubNotConsts.ServiceState)));
        m_Subscriptions.Add(SubNotConsts.QueueState, new SubscriptionData(SubNotConsts.QueueState, BuildSubscribeRequest(
            SubNotConsts.QueueState)));
    }

    private SIPRequest BuildSubscribeRequest(string eventName)
    {
        SIPURI contactUri = m_SipTransport.SipChannel.SIPChannelContactURI;
        SIPRequest subscribe = SIPRequest.CreateBasicRequest(SIPMethodsEnum.SUBSCRIBE, m_NotifierSipUri,
            contactUri, null, contactUri, null);
        subscribe.Header.Event = eventName;
        subscribe.Header.Expires = DEFAULT_EXPIRES_SECONDS;
        return subscribe;
    }

    private void OnSipRequestReceived(SIPRequest sipRequest, SIPEndPoint remoteEndPoint, SipTransport sipTransportManager)
    {
        EnqueueWork(() => { HandleSipRequest(sipRequest, remoteEndPoint, sipTransportManager); });
    }

    private void HandleSipRequest(SIPRequest sipRequest, SIPEndPoint remoteEndPoint, SipTransport sipTransportManager)
    {
        if (sipRequest.Method != SIPMethodsEnum.NOTIFY)
        {   // Only need to handle NOTIFY requests
            SIPResponse notAllowed = SipUtils.BuildResponse(sipRequest, SIPResponseStatusCodesEnum.MethodNotAllowed,
                "Method Not Allowed", m_SipTransport.SipChannel, null);
            m_SipTransport.StartServerNonInviteTransaction(sipRequest, m_NotifierIPEndPoint, null, notAllowed);
            return;
        }

        if (sipRequest.Header.Event == null)
        {
            // Not expected because the SUBSCRIBE SIP requests are generated by this application.
            return;
        }

        SubscriptionData? subscriptionData = GetSubscriptionData(sipRequest.Header.Event);
        if (subscriptionData == null)
        {
            // Not expected because the SUBSCRIBE SIP requests are generated by this application.
            return;
        }

        if (sipRequest.Header.Event != SubNotConsts.ElementState && sipRequest.Header.Event != SubNotConsts.ServiceState &&
            sipRequest.Header.Event != SubNotConsts.QueueState)
        {
            // Not expected since the SUBSCRIBE SIP request is generated by this application.
            return;
        }

        IPEndPoint remIpe = remoteEndPoint.GetIPEndPoint();
        // Send an 200 OK response
        SIPResponse OkResponse = SipUtils.BuildResponse(sipRequest, SIPResponseStatusCodesEnum.Ok, "OK",
            m_SipTransport.SipChannel, null);
        m_SipTransport.StartServerNonInviteTransaction(sipRequest, remIpe, null, OkResponse);

        if (sipRequest.Header.SubscriptionState != null && sipRequest.Header.SubscriptionState == "terminated")
            subscriptionData.SubscriptionState = SubscriptionStateEnum.Terminated;

        switch (sipRequest.Header.Event)
        {
            case SubNotConsts.ElementState:
                ProcessElementStateNotify(sipRequest, subscriptionData);
                break;
            case SubNotConsts.ServiceState:
                ProcessServiceStateNotify(sipRequest, subscriptionData);
                break;
            case SubNotConsts.QueueState:
                ProcessQueueStateNotify(sipRequest, subscriptionData);
                break;
        }

    }

    private void ProcessElementStateNotify(SIPRequest sipRequest, SubscriptionData subscriptionData)
    {
        string? strElementState = sipRequest.GetContentsOfType(Body.ContentTypes.ElementState);
        if (strElementState == null)
        {   // No body sent with the NOTIFY request. It may be because the subscription has been terminated.
            if (subscriptionData.SubscriptionState != SubscriptionStateEnum.Terminated)
                Console.WriteLine($"Error: No NOTIFY body provided for Element State at {TimeUtils.GetCurrentNenaTimestamp()}");

            return;
        }

        ElementState elementState = JsonHelper.DeserializeFromString<ElementState>(strElementState);
        if (elementState == null)
        {
            Console.WriteLine($"Error deserializing ElementState at {TimeUtils.GetCurrentNenaTimestamp()}");
            return;
        }

        Console.WriteLine($"Element State = {elementState.state} at {TimeUtils.GetCurrentNenaTimestamp()}");
    }

    private void ProcessServiceStateNotify(SIPRequest sipRequest, SubscriptionData subscriptionData)
    {
        string? strSubscriptionState = sipRequest.GetContentsOfType(Body.ContentTypes.ServiceState);
        if (strSubscriptionState == null)
        {
            if (subscriptionData.SubscriptionState != SubscriptionStateEnum.Terminated)
                Console.WriteLine($"Error: No NOTIFY body provided for Service State at {TimeUtils.GetCurrentNenaTimestamp()}");

            return;
        }

        ServiceState serviceState = JsonHelper.DeserializeFromString<ServiceState>(strSubscriptionState);
        if (serviceState == null)
        {
            Console.WriteLine($"Error deserializing ServiceState at {TimeUtils.GetCurrentNenaTimestamp()}");
            return;
        }

        Console.WriteLine($"Service State = {serviceState.serviceState.state} at {TimeUtils.GetCurrentNenaTimestamp()}");
        Console.WriteLine($"Security Posture = {serviceState.securityPosture.posture} at {TimeUtils.GetCurrentNenaTimestamp()}");
    }

    private void ProcessQueueStateNotify(SIPRequest sipRequest, SubscriptionData subscriptionData)
    {
        string? strQueueState = sipRequest.GetContentsOfType(Body.ContentTypes.QueueState);
        if (strQueueState == null)
        {
            if (subscriptionData.SubscriptionState != SubscriptionStateEnum.Terminated)
                Console.WriteLine($"Error: No NOTIFY body provided for Queue State at {TimeUtils.GetCurrentNenaTimestamp()}");
            return;
        }

        QueueState queueState = JsonHelper.DeserializeFromString<QueueState>(strQueueState);
        if (queueState == null)
        {
            Console.WriteLine($"Error deserializing QueueState at {TimeUtils.GetCurrentNenaTimestamp()}");
            return;
        }

        Console.WriteLine($"Queue State = {queueState.state} at {TimeUtils.GetCurrentNenaTimestamp()}");
        Console.WriteLine($"Queue Length = {queueState.queueLength} at {TimeUtils.GetCurrentNenaTimestamp()}");

    }

    private SubscriptionData? GetSubscriptionData(string strEvent)
    {
        if (m_Subscriptions.TryGetValue(strEvent, out SubscriptionData? subscriptionData) == false)
            return null;

        return subscriptionData;
    }

    protected override void DoTimedEvents()
    {
        foreach (SubscriptionData subscriptionData in m_Subscriptions.Values)
        {
            if (subscriptionData.SubscriptionState == SubscriptionStateEnum.Idle)
            {   // Start the subscription request
                subscriptionData.SubscriptionState = SubscriptionStateEnum.Subscribing;
                m_SipTransport.StartClientNonInviteTransaction(subscriptionData.SubscribeRequest,
                    m_NotifierIPEndPoint, OnSubscribeRequestComplete, 5000);
            }
            else if (subscriptionData.SubscriptionState == SubscriptionStateEnum.Subscribed)
            {   // Check to see if its time to refresh the subscription
                if ((DateTime.Now - subscriptionData.LastSubscribeTime).TotalSeconds >= subscriptionData.ExpiresSeconds)
                {   // Its time to resubscribe
                    subscriptionData.SubscriptionState = SubscriptionStateEnum.ReSubscribing;
                    subscriptionData.LastCSeqNumber += 1;
                    subscriptionData.SubscribeRequest.Header.CSeq = subscriptionData.LastCSeqNumber;
                    m_SipTransport.StartClientNonInviteTransaction(subscriptionData.SubscribeRequest,
                        m_NotifierIPEndPoint, OnSubscribeRequestComplete, 5000);
                }
            }
        }
    }

    private void OnSubscribeRequestComplete(SIPRequest sipRequest, SIPResponse? sipResponse, IPEndPoint remoteEndPoint, 
        SipTransport sipTransport, SipTransactionBase Transaction)
    {
        EnqueueWork(() => { HandleSubscribeRequestComplete(sipRequest, sipResponse, remoteEndPoint, sipTransport, 
            Transaction); });
    }

    private void HandleSubscribeRequestComplete(SIPRequest sipRequest, SIPResponse? sipResponse, IPEndPoint remoteEndPoint,
        SipTransport sipTransport, SipTransactionBase Transaction)
    {
        if (sipRequest.Header.Event == null)
        {
            Console.WriteLine($"Error: SUBSCRIBE request with no Event header.");
            return;
        }

        SubscriptionData? subscriptionData = GetSubscriptionData(sipRequest.Header.Event);
        if (subscriptionData == null)
        {
            Console.WriteLine($"SubscriptionData not found for Event = {sipRequest.Header.Event}");
            return;
        }

        if (sipResponse == null)
        {   // The request timed out. 
            Console.WriteLine($"SUBSCRIBE request timeout for Event = {sipRequest.Header.Event} at " +
                $"{TimeUtils.GetCurrentNenaTimestamp()}");
            subscriptionData.SubscriptionState = SubscriptionStateEnum.Idle;
            return;
        }

        if (sipResponse.Status == SIPResponseStatusCodesEnum.Ok)
        {
            subscriptionData.SubscriptionState = SubscriptionStateEnum.Subscribed;
            subscriptionData.LastSubscribeTime = DateTime.Now;
            if (sipResponse.Header.Expires != -1)
                subscriptionData.ExpiresSeconds = sipResponse.Header.Expires;
        }
        else
            Console.WriteLine($"SUBSCRIBE request rejected with a status code of: {sipResponse.StatusCode} " +
                $"for Event = {sipRequest.Header.Event} at {TimeUtils.GetCurrentNenaTimestamp()}");
    }

    /// <summary>
    /// Un-subscribes to all current subscriptions. This method sends a SUBSCRIBE request with an Expires = 0
    /// header and waits for a response from the server (the notifier).
    /// </summary>
    public void UnsubscribeToAll()
    {
        ManualResetEvent Mre = new ManualResetEvent(false);
        EnqueueWork(() => { DoUnsubscribeAll(Mre); });
        Mre.WaitOne();
    }

    private void DoUnsubscribeAll(ManualResetEvent Mre)
    {
        foreach (SubscriptionData subscriptionData in m_Subscriptions.Values)
        {
            if (subscriptionData.SubscriptionState == SubscriptionStateEnum.Subscribed)
            {
                subscriptionData.SubscribeRequest.Header.Expires = 0;
                subscriptionData.LastCSeqNumber += 1;
                subscriptionData.SubscribeRequest.Header.CSeq = subscriptionData.LastCSeqNumber;
                ClientNonInviteTransaction Cnit = m_SipTransport.StartClientNonInviteTransaction(subscriptionData.SubscribeRequest,
                    m_NotifierIPEndPoint, null, 1000);
                _ = Cnit.WaitForCompletionAsync();     // Forces a synchronous wait for completion
            }
        }

        Mre.Set();
    }
}
